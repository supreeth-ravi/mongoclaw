MongoClaw: Declarative AI Agents for MongoDB
1. PROBLEM STATEMENT
Core Problems MongoClaw Solves:
Problem 1: AI Blocking Database Operations

Developers call AI APIs directly in app code (synchronous)
Database writes wait for slow AI responses (2-10 seconds)
API timeouts, poor user experience, cascade failures

Problem 2: Manual Infrastructure Hell

Building CDC pipelines manually (change streams + workers)
Writing boilerplate: queues, retries, error handling, observability
Managing separate codebases for app logic + agent orchestration

Problem 3: Lack of Declarative Control

No way to say "watch this collection, enrich with AI, write back"
Everything requires imperative code and custom infrastructure
Hard to version, test, and manage agent logic

Problem 4: Production Safety Concerns

AI failures shouldn't break database transactions
Need isolation between database and AI processing
Cost controls and rate limiting are manual

Problem 5: Poor Observability

Can't see which agents ran, what they did, or why they failed
Debugging requires correlating logs across systems
No centralized view of AI enrichment pipeline


2. SOLUTION ARCHITECTURE
High-Level Architecture
┌─────────────────────────────────────────────────────────────┐
│                      YOUR APPLICATION                        │
│  (Just writes data normally - no AI code)                   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                    MONGODB CLUSTER                           │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐  │
│  │   tickets    │  │   products   │  │   agents (cfg)  │  │
│  └──────────────┘  └──────────────┘  └─────────────────┘  │
│                                                              │
│  ┌────────────────────────────────────────────────────┐   │
│  │  Change Stream (real-time CDC)                      │   │
│  └────────────────────────────────────────────────────┘   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              MONGOCLAW RUNTIME (External)                    │
│                                                              │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  Agent Dispatcher                                      │ │
│  │  - Watches change streams                             │ │
│  │  - Matches events to agents                           │ │
│  │  - Queues work (in-memory or Redis)                   │ │
│  └───────────────────────────────────────────────────────┘ │
│                     │                                        │
│                     ▼                                        │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  Worker Pool (concurrent, rate-limited)               │ │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐              │ │
│  │  │Worker 1 │  │Worker 2 │  │Worker N │              │ │
│  │  └─────────┘  └─────────┘  └─────────┘              │ │
│  └───────────────────────────────────────────────────────┘ │
│                     │                                        │
│                     ▼                                        │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  AI Provider Router                                    │ │
│  │  (OpenAI, Anthropic, Azure, Local models)            │ │
│  └───────────────────────────────────────────────────────┘ │
│                     │                                        │
│                     ▼                                        │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  Result Writer (transactional, idempotent)            │ │
│  └───────────────────────────────────────────────────────┘ │
│                     │                                        │
│                     ▼                                        │
│  ┌───────────────────────────────────────────────────────┐ │
│  │  Observability Layer                                   │ │
│  │  - Metrics (Prometheus)                               │ │
│  │  - Traces (OpenTelemetry)                             │ │
│  │  - Logs (structured JSON)                             │ │
│  └───────────────────────────────────────────────────────┘ │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
         (Writes enriched data back to MongoDB)

3. DETAILED COMPONENT DESIGN
3.1 Agent Definition (Declarative Config)
Agents are stored as documents in MongoDB:
javascript// Collection: mongoclaw.agents
{
  _id: ObjectId("..."),
  name: "ticket_classifier",
  
  // What to watch
  watch: {
    database: "myapp",
    collection: "support_tickets",
    operations: ["insert", "update"],  // insert, update, replace, delete
    filter: {
      status: "new",  // Optional: only process matching docs
      "ai_classification": { $exists: false }  // Skip already processed
    }
  },
  
  // AI configuration
  ai: {
    provider: "anthropic",  // anthropic, openai, azure, bedrock
    model: "claude-sonnet-4",
    temperature: 0.7,
    max_tokens: 1000,
    
    // Prompt template (Jinja2 or Handlebars)
    prompt: `
      Classify this support ticket:
      
      Title: {{document.title}}
      Description: {{document.description}}
      User: {{document.user_email}}
      
      Return JSON with: category, priority, sentiment, suggested_team
    `,
    
    // Optional: Extract specific fields from response
    response_schema: {
      type: "json",
      schema: {
        category: "string",
        priority: "enum[low,medium,high,urgent]",
        sentiment: "enum[positive,neutral,negative]",
        suggested_team: "string"
      }
    }
  },
  
  // Where to write results
  write: {
    database: "myapp",
    collection: "support_tickets",
    
    // Update strategy
    strategy: "merge",  // merge, replace, append, custom
    
    // Field mapping
    fields: {
      "ai_classification": "{{ai_response}}",
      "classified_at": "{{now}}",
      "classification_model": "{{model}}"
    },
    
    // Idempotency
    idempotency_key: "{{document._id}}_{{operation}}_{{timestamp}}"
  },
  
  // Execution policies
  execution: {
    retry: {
      max_attempts: 3,
      backoff: "exponential",  // exponential, linear, fixed
      initial_delay_ms: 1000,
      max_delay_ms: 60000
    },
    
    timeout_ms: 30000,
    
    rate_limit: {
      max_per_minute: 60,
      max_concurrent: 10
    },
    
    cost_limit: {
      max_per_day_usd: 100,
      alert_threshold_usd: 80
    },
    
    dead_letter: {
      enabled: true,
      collection: "mongoclaw.dead_letters",
      max_age_days: 30
    }
  },
  
  // State & metadata
  enabled: true,
  version: 1,
  created_at: ISODate("2026-02-20T10:00:00Z"),
  updated_at: ISODate("2026-02-20T10:00:00Z"),
  created_by: "user@example.com",
  
  // Stats (updated by runtime)
  stats: {
    total_processed: 1247,
    total_successes: 1230,
    total_failures: 17,
    avg_latency_ms: 2340,
    last_execution: ISODate("2026-02-20T12:34:56Z")
  }
}
3.2 Change Stream Watcher
python# Pseudocode for the dispatcher

class ChangeStreamWatcher:
    def __init__(self, mongodb_uri, agents_collection):
        self.client = MongoClient(mongodb_uri)
        self.agents = self.load_agents(agents_collection)
        self.resume_token = self.load_resume_token()
    
    def start(self):
        # Watch ALL collections (or specific ones)
        pipeline = [
            {
                '$match': {
                    'operationType': {'$in': ['insert', 'update', 'replace', 'delete']}
                }
            }
        ]
        
        with self.client.watch(
            pipeline=pipeline,
            resume_after=self.resume_token,
            full_document='updateLookup'
        ) as stream:
            for change in stream:
                self.process_change(change)
                
                # Checkpoint resume token periodically
                if self.should_checkpoint():
                    self.save_resume_token(stream.resume_token)
    
    def process_change(self, change):
        # Find matching agents
        matching_agents = self.find_matching_agents(change)
        
        for agent in matching_agents:
            # Enqueue work
            work_item = WorkItem(
                agent_id=agent['_id'],
                change_event=change,
                document=change.get('fullDocument'),
                operation=change['operationType'],
                timestamp=change['clusterTime']
            )
            
            self.queue.enqueue(work_item)
    
    def find_matching_agents(self, change):
        matched = []
        
        for agent in self.agents:
            # Match database.collection
            if (agent['watch']['database'] == change['ns']['db'] and
                agent['watch']['collection'] == change['ns']['coll']):
                
                # Match operation type
                if change['operationType'] in agent['watch']['operations']:
                    
                    # Match filter (if specified)
                    if self.matches_filter(change, agent['watch'].get('filter')):
                        matched.append(agent)
        
        return matched
3.3 Worker Pool
pythonclass AgentWorker:
    def __init__(self, worker_id, ai_router, result_writer):
        self.worker_id = worker_id
        self.ai_router = ai_router
        self.result_writer = result_writer
    
    async def process(self, work_item):
        agent = work_item.agent
        document = work_item.document
        
        with trace_span(f"agent.{agent['name']}"):
            try:
                # 1. Render prompt template
                prompt = self.render_prompt(agent['ai']['prompt'], document)
                
                # 2. Call AI (with retry)
                ai_response = await self.call_ai_with_retry(
                    provider=agent['ai']['provider'],
                    model=agent['ai']['model'],
                    prompt=prompt,
                    retry_config=agent['execution']['retry']
                )
                
                # 3. Parse/validate response
                parsed_response = self.parse_response(
                    ai_response,
                    agent['ai'].get('response_schema')
                )
                
                # 4. Write result back to MongoDB (idempotent)
                await self.result_writer.write(
                    agent=agent,
                    document=document,
                    ai_response=parsed_response,
                    work_item=work_item
                )
                
                # 5. Update metrics
                self.metrics.record_success(agent['_id'])
                
                return Success(work_item)
                
            except RetryableError as e:
                # Will be retried by queue
                self.metrics.record_retry(agent['_id'])
                raise
                
            except PermanentError as e:
                # Send to dead letter queue
                await self.dead_letter_queue.send(work_item, error=e)
                self.metrics.record_failure(agent['_id'])
                return Failure(work_item, e)
3.4 Result Writer (Idempotent)
pythonclass ResultWriter:
    async def write(self, agent, document, ai_response, work_item):
        write_config = agent['write']
        
        # Generate idempotency key
        idempotency_key = self.render_template(
            write_config['idempotency_key'],
            context={
                'document': document,
                'operation': work_item.operation,
                'timestamp': work_item.timestamp
            }
        )
        
        # Check if already written (idempotency)
        existing = await self.db[write_config['database']][
            write_config['collection']
        ].find_one({
            '_id': document['_id'],
            f'mongoclaw.executions.{idempotency_key}': {'$exists': True}
        })
        
        if existing:
            logger.info(f"Already processed: {idempotency_key}")
            return  # Skip duplicate
        
        # Prepare update
        update_fields = self.render_fields(
            write_config['fields'],
            context={
                'ai_response': ai_response,
                'now': datetime.utcnow(),
                'model': agent['ai']['model']
            }
        )
        
        # Atomic write with idempotency record
        result = await self.db[write_config['database']][
            write_config['collection']
        ].update_one(
            {'_id': document['_id']},
            {
                '$set': update_fields,
                '$push': {
                    'mongoclaw.executions': {
                        'key': idempotency_key,
                        'agent_id': agent['_id'],
                        'agent_name': agent['name'],
                        'executed_at': datetime.utcnow(),
                        'tokens_used': ai_response.get('usage', {})
                    }
                }
            }
        )
        
        return result
```

---

## **4. SCALABILITY SOLUTIONS**

### **4.1 Horizontal Scaling**
```
┌─────────────────────────────────────────────────────────┐
│                   MongoDB Change Streams                 │
│                 (Distributed, resumable)                 │
└────────────────────────┬────────────────────────────────┘
                         │
          ┌──────────────┼──────────────┐
          │              │              │
          ▼              ▼              ▼
   ┌──────────┐   ┌──────────┐   ┌──────────┐
   │ Runtime 1│   │ Runtime 2│   │ Runtime N│
   │ (Leader) │   │(Follower)│   │(Follower)│
   └──────────┘   └──────────┘   └──────────┘
          │              │              │
          └──────────────┴──────────────┘
                         │
                         ▼
              ┌──────────────────┐
              │  Shared Queue    │
              │  (Redis/RabbitMQ)│
              └──────────────────┘
Strategy:

Leader Election: Use MongoDB's findAndModify or Raft consensus
Work Distribution: Round-robin or consistent hashing
State Sharing: Store resume tokens and agent stats in MongoDB
Queue Backend: Redis Streams or RabbitMQ for work distribution

4.2 Partitioning
python# Partition by collection
runtime_1: watches ["users", "products"]
runtime_2: watches ["orders", "tickets"]

# Or partition by agent
runtime_1: runs agents [a1, a2, a3]
runtime_2: runs agents [a4, a5, a6]
4.3 Rate Limiting & Backpressure
pythonclass AdaptiveRateLimiter:
    def __init__(self):
        self.token_bucket = TokenBucket(rate=100, capacity=200)
        self.circuit_breaker = CircuitBreaker(failure_threshold=0.5)
    
    async def acquire(self, agent_id):
        # Global rate limit
        await self.token_bucket.acquire()
        
        # Per-agent rate limit
        agent_limiter = self.get_agent_limiter(agent_id)
        await agent_limiter.acquire()
        
        # Circuit breaker check
        if self.circuit_breaker.is_open(agent_id):
            raise CircuitOpen(f"Agent {agent_id} circuit is open")
    
    def on_success(self, agent_id):
        self.circuit_breaker.record_success(agent_id)
    
    def on_failure(self, agent_id):
        self.circuit_breaker.record_failure(agent_id)
4.4 Caching Layer
python# Cache AI responses for identical inputs
class AICache:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def get_cache_key(self, agent_id, document):
        # Hash the document content
        content_hash = hashlib.sha256(
            json.dumps(document, sort_keys=True).encode()
        ).hexdigest()
        return f"ai_cache:{agent_id}:{content_hash}"
    
    async def get(self, agent_id, document):
        key = self.get_cache_key(agent_id, document)
        cached = await self.redis.get(key)
        
        if cached:
            return json.loads(cached)
        return None
    
    async def set(self, agent_id, document, response, ttl=3600):
        key = self.get_cache_key(agent_id, document)
        await self.redis.setex(
            key,
            ttl,
            json.dumps(response)
        )

5. SECURITY SOLUTIONS
5.1 Authentication & Authorization
javascript// Agent RBAC
{
  agent_id: "ticket_classifier",
  
  // Who can create/modify/delete this agent
  acl: {
    owner: "team_support@company.com",
    editors: ["admin@company.com"],
    viewers: ["analytics@company.com"]
  },
  
  // MongoDB credentials (scoped)
  mongodb: {
    connection_string: "mongodb+srv://...",
    
    // Principle of least privilege
    permissions: {
      read: ["myapp.support_tickets"],
      write: ["myapp.support_tickets.ai_classification"]
    }
  },
  
  // AI provider credentials (encrypted)
  ai_credentials: {
    provider: "anthropic",
    api_key_ref: "vault://secrets/anthropic_key",  // External secret manager
    organization_id: "org_123"
  }
}
5.2 Data Isolation
python# Multi-tenancy support
class TenantIsolation:
    def filter_documents(self, agent, document):
        # Ensure agent can only see documents from its tenant
        if 'tenant_id' in agent.get('watch', {}).get('filter', {}):
            required_tenant = agent['watch']['filter']['tenant_id']
            
            if document.get('tenant_id') != required_tenant:
                raise AuthorizationError(
                    f"Agent {agent['name']} cannot access tenant {document['tenant_id']}"
                )
5.3 Secrets Management
python# Integration with Vault, AWS Secrets Manager, etc.
class SecretsManager:
    def resolve_api_key(self, key_ref):
        if key_ref.startswith('vault://'):
            return self.vault_client.get_secret(key_ref)
        
        elif key_ref.startswith('aws://'):
            return self.aws_secrets_client.get_secret(key_ref)
        
        elif key_ref.startswith('env://'):
            return os.getenv(key_ref.replace('env://', ''))
        
        else:
            raise ValueError(f"Unknown secret reference: {key_ref}")
5.4 Audit Logging
python# Every action is logged
audit_log = {
    "timestamp": "2026-02-20T12:34:56Z",
    "event": "agent.execution",
    "agent_id": "ticket_classifier",
    "agent_name": "Ticket Classifier",
    "user": "user@example.com",
    "document_id": "507f1f77bcf86cd799439011",
    "operation": "update",
    "ai_provider": "anthropic",
    "ai_model": "claude-sonnet-4",
    "tokens_used": 1234,
    "cost_usd": 0.0123,
    "latency_ms": 2340,
    "status": "success",
    "ip_address": "10.0.1.42",
    "trace_id": "abc123def456"
}
5.5 PII Handling
python# Automatic PII redaction before sending to AI
class PIIRedactor:
    def __init__(self):
        self.patterns = {
            'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            'ssn': r'\b\d{3}-\d{2}-\d{4}\b',
            'credit_card': r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b',
            'phone': r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b'
        }
    
    def redact(self, text, fields_to_redact):
        redacted = text
        
        for field in fields_to_redact:
            pattern = self.patterns.get(field)
            if pattern:
                redacted = re.sub(pattern, '[REDACTED]', redacted)
        
        return redacted

# In agent config
{
  ai: {
    pii_redaction: {
      enabled: true,
      fields: ['email', 'ssn', 'credit_card']
    }
  }
}

6. EASY INTEGRATION SOLUTIONS
6.1 Zero-Code Setup
bash# Install
npm install -g mongoclaw
# or
pip install mongoclaw

# Initialize
mongoclaw init --mongodb-uri="mongodb+srv://..." --ai-provider="anthropic"

# Start runtime
mongoclaw start
6.2 SDK / Client Libraries
javascript// Node.js SDK
const { MongoClaw } = require('mongoclaw');

const claw = new MongoClaw({
  mongodbUri: process.env.MONGODB_URI,
  anthropicApiKey: process.env.ANTHROPIC_API_KEY
});

// Create agent programmatically
await claw.agents.create({
  name: "ticket_classifier",
  watch: {
    database: "myapp",
    collection: "support_tickets",
    operations: ["insert"]
  },
  ai: {
    provider: "anthropic",
    model: "claude-sonnet-4",
    prompt: "Classify this ticket: {{document.description}}"
  },
  write: {
    collection: "support_tickets",
    fields: {
      "ai_classification": "{{ai_response}}"
    }
  }
});

// Start watching
await claw.start();
python# Python SDK
from mongoclaw import MongoClaw

claw = MongoClaw(
    mongodb_uri=os.getenv("MONGODB_URI"),
    anthropic_api_key=os.getenv("ANTHROPIC_API_KEY")
)

# Create agent
claw.agents.create(
    name="ticket_classifier",
    watch={
        "database": "myapp",
        "collection": "support_tickets",
        "operations": ["insert"]
    },
    ai={
        "provider": "anthropic",
        "model": "claude-sonnet-4",
        "prompt": "Classify this ticket: {{document.description}}"
    },
    write={
        "collection": "support_tickets",
        "fields": {
            "ai_classification": "{{ai_response}}"
        }
    }
)

# Start
claw.start()
```

### **6.3 Web UI / Dashboard**
```
┌─────────────────────────────────────────────────────┐
│  MongoClaw Dashboard                                 │
├─────────────────────────────────────────────────────┤
│                                                      │
│  Agents                       [+ Create Agent]      │
│  ┌──────────────────────────────────────────────┐  │
│  │ ticket_classifier                    ✓ Active│  │
│  │ Processed: 1,247  Success: 99.2%             │  │
│  │ Avg latency: 2.3s  Cost today: $12.34       │  │
│  └──────────────────────────────────────────────┘  │
│                                                      │
│  ┌──────────────────────────────────────────────┐  │
│  │ product_tagger                       ✓ Active│  │
│  │ Processed: 543  Success: 100%                │  │
│  │ Avg latency: 1.8s  Cost today: $5.67        │  │
│  └──────────────────────────────────────────────┘  │
│                                                      │
│  Recent Executions                                  │
│  ┌──────────────────────────────────────────────┐  │
│  │ 12:34:56  ticket_classifier  ✓  2.1s  $0.01 │  │
│  │ 12:34:55  product_tagger     ✓  1.9s  $0.01 │  │
│  │ 12:34:54  ticket_classifier  ✗  timeout      │  │
│  └──────────────────────────────────────────────┘  │
│                                                      │
│  [View Logs]  [Metrics]  [Settings]                │
└─────────────────────────────────────────────────────┘
6.4 CLI
bash# List agents
mongoclaw agents list

# Create agent from YAML
mongoclaw agents create -f agent.yaml

# Enable/disable
mongoclaw agents enable ticket_classifier
mongoclaw agents disable product_tagger

# View logs
mongoclaw logs --agent=ticket_classifier --tail

# Metrics
mongoclaw metrics --agent=ticket_classifier --last=1h

# Test agent (dry run)
mongoclaw test ticket_classifier --document='{"title":"Help!"}'
6.5 Infrastructure as Code
yaml# agent.yaml
apiVersion: mongoclaw.dev/v1
kind: Agent
metadata:
  name: ticket-classifier
spec:
  watch:
    database: myapp
    collection: support_tickets
    operations: [insert, update]
    filter:
      status: new
  
  ai:
    provider: anthropic
    model: claude-sonnet-4
    temperature: 0.7
    prompt: |
      Classify this support ticket:
      
      Title: {{document.title}}
      Description: {{document.description}}
      
      Return JSON with: category, priority, sentiment
  
  write:
    collection: support_tickets
    strategy: merge
    fields:
      ai_classification: "{{ai_response}}"
      classified_at: "{{now}}"
  
  execution:
    retry:
      maxAttempts: 3
      backoff: exponential
    rateLimit:
      maxPerMinute: 60
    costLimit:
      maxPerDayUsd: 100
bash# Apply config
mongoclaw apply -f agent.yaml

# Version control
git add agent.yaml
git commit -m "Add ticket classifier agent"
git push
6.6 MongoDB Atlas Integration
javascript// Native Atlas Triggers integration (optional alternative to runtime)
// MongoClaw can compile agents into Atlas Triggers

mongoclaw compile ticket_classifier --target=atlas-trigger

// Generates Atlas Function:
exports = async function(changeEvent) {
  const mongoclaw = require('mongoclaw-atlas');
  return await mongoclaw.execute('ticket_classifier', changeEvent);
};

7. KEY DIFFERENTIATORS
FeatureMongoClawManual CDC PipelineLangChain + MongoDBAtlas TriggersDeclarative✅ YAML/JSON config❌ Imperative code❌ Python code⚠️ LimitedAsync by default✅ Non-blocking⚠️ Manual setup❌ Sync usually✅ AsyncBuilt-in retries✅ Automatic❌ Manual❌ Manual⚠️ LimitedObservability✅ Full tracing❌ DIY❌ DIY⚠️ Basic logsMulti-provider AI✅ Any LLM✅ Any✅ Any❌ Atlas onlyCost controls✅ Built-in❌ Manual❌ Manual❌ ManualIdempotency✅ Automatic❌ Manual❌ Manual⚠️ LimitedHorizontal scaling✅ Easy⚠️ Complex⚠️ Complex✅ AutoOpen source✅ YesN/A✅ Yes❌ Closed

8. DEPLOYMENT OPTIONS
Option 1: Self-Hosted Runtime
bashdocker run -d \
  -e MONGODB_URI="mongodb+srv://..." \
  -e ANTHROPIC_API_KEY="..." \
  mongoclaw/runtime:latest
Option 2: Kubernetes
yamlapiVersion: apps/v1
kind: Deployment
metadata:
  name: mongoclaw
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: mongoclaw
        image: mongoclaw/runtime:latest
        env:
        - name: MONGODB_URI
          valueFrom:
            secretKeyRef:
              name: mongoclaw-secrets
              key: mongodb-uri
```

### **Option 3: Managed Service (Future)**
```
MongoClaw Cloud
- Zero infrastructure
- Auto-scaling
- Built-in monitoring
- Pay per execution

9. SUMMARY: WHAT MONGOCLAW SOLVES
✅ Problem: AI blocking database → Solution: Async-first architecture
✅ Problem: Manual infrastructure → Solution: Declarative agents
✅ Problem: No observability → Solution: Built-in tracing & metrics
✅ Problem: No cost controls → Solution: Rate limits & budgets
✅ Problem: Hard to scale → Solution: Horizontal scaling + partitioning
✅ Problem: Security concerns → Solution: RBAC, encryption, audit logs
✅ Problem: Complex integration → Solution: SDK, CLI, UI, IaC
One-liner: "MongoClaw makes your MongoDB data intelligent with zero infrastructure - just declare agents, we handle the rest."
